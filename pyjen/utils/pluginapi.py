"""Primitives for interacting with the PyJen plugin API"""
import os

import xml.etree.ElementTree as ElementTree
from pyjen.utils.plugin_base import PluginBase

# Path where all PyJen plugins are stored
PYJEN_PLUGIN_FOLDER = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "plugins"))


class PluginXML(object):
    """Class used to process XML configuration information associated with Jenkins plugins"""
    def __init__(self, xml_node):
        """
        :param xml_node: the XML sub-tree defining the properties of this plugin
        :type xml_node: :class:`xml.etree.ElementTree`
        """
        self._root = xml_node

    def get_module_name(self):
        """Gets the name of the plugin

        :returns: the plugin name
        :rtype: :class:`str`
        """
        attr = self._root.attrib['plugin']
        parts = attr.split('@')
        return parts[0]

    def get_class_name(self):
        """Gets the Java class name of the plugin

        :returns: the Java class name
        :rtype: :class:`str`
        """

        if "class" in self._root.attrib:
            return self._root.attrib['class']
        else:
            return self._root.tag

    def get_version(self):
        """Gets the version of the plugin

        :returns: the plugin version
        :rtype: :class:`str`
        """
        attr = self._root.attrib['plugin']
        parts = attr.split('@')
        return parts[1]


def get_plugins():
    """Returns list of classes for all plugins supported by PyJen

    :returns: list of classes for all PyJen plugins
    :rtype: :class:`list` of :class:`~.PluginBase` derived objects
    """
    all_modules = _load_modules(PYJEN_PLUGIN_FOLDER)
    retval = []
    for module in all_modules:
        retval.extend(_get_plugin_classes(module))
    return retval


def get_view_plugins():
    """Returns a list of plugins that extend the default Jenkins View type

    :returns: list of plugins that extend the default Jenkins View type
    :rtype: :class:`list` of :class:`~.utils.plugin_base.PluginBase` derived classes
    """
    from pyjen.view import View
    retval = []
    for plugin in get_plugins():
        if issubclass(plugin, View):
            retval.append(plugin)

    return retval


def get_job_plugins():
    """Returns a list of plugins that extend the default Jenkins Job type

    :returns: list of plugins that extend the default Jenkins Job type
    :rtype: :class:`list` of :class:`~.utils.plugin_base.PluginBase` derived classes
    """
    from pyjen.job import Job
    retval = []
    for plugin in get_plugins():
        if issubclass(plugin, Job):
            retval.append(plugin)
    return retval


def create_xml_plugin(xml_node):
    """Instantiates the appropriate XML-compatible PyJen plugin

    :param xml_node: the node of the XML configuration defining the plugin configuration
    :type xml_node: xml.etree.ElementTree
    :returns: a pre-initialized plugin of the appropriate type, or None if no supported plugin can be found
    :rtype: :class:`~.utils.plugin_base.PluginBase` derived class
    """
    pluginxml = PluginXML(xml_node)
    plugin = find_plugin(pluginxml.get_class_name())
    if plugin is None:
        return None

    return plugin(xml_node)


def find_plugin(plugin_type):
    """Locates a PyJen plugin of the given type

    :param str plugin_type: the descriptive type-name for the plugin to find
    :returns: reference to the plugin class for the specified type, or None if a compatible plugin could not be found
    """
    for plugin in get_plugins():
        if plugin.type == plugin_type:
            return plugin
    return None


def init_extension_plugin(dataio, jenkins_master):
    """Instantiates a plugin that extends one of the Jenkins native objects such as a view or job

    :param dataio: Jenkins REST API interface, initialized with the connection parameters of the new object
    :param jenkins_master: Instance of the Jenkins master object that manages this entity
    :returns: PyJen plugin pre-initialized with the source data, or None if no compatible plugin could be found
    :rtype: :class:`~.utils.pluginbase.PluginBase` derived object
    """
    pluginxml = PluginXML(ElementTree.fromstring(dataio.config_xml))

    for plugin in get_plugins():
        if plugin.type == pluginxml.get_class_name():
            return plugin(dataio, jenkins_master)
    return None


def get_plugin_name(xml_node):
    """Extracts the name of a plugin from an XML snippet

    :param xml_node: the node of the XML configuration defining the plugin configuration
    :type xml_node: xml.etree.ElementTree
    :returns: Name of the plugin this snippet is generated by
    :rtype: :class:`str`
    """
    return PluginXML(xml_node).get_class_name()


def _get_plugin_classes(module):
    """Gets a list of all PyJen plugins from a given Python module

    :param module: A Python module object to be processed
    :returns: list of classes found within the given module that implement PyJen plugin interfaces
    :rtype: :class:`list` of :class:`~.PluginBase` objects
    """
    import inspect
    retval = []
    for name, obj in inspect.getmembers(module, inspect.isclass):
        if obj.__module__.startswith("pyjen.plugins."):
            if issubclass(obj, PluginBase):
                retval.append(obj)

    return retval


def _load_modules(path):
    """Gets a list of all modules found in a given path

    :param str path: path containing Python modules to be loaded
    :return: :class:`list` of objects of type 'module' found in the specified folder
    :rtype: :class:`list` of Python modules
    """
    import pkgutil
    import importlib
    retval = []

    for loader, name, ispkg in pkgutil.walk_packages([path], "pyjen.plugins."):
        if not ispkg:
            cur_mod = importlib.import_module(name)
            #cur_mod = loader.find_module(name).load_module(name)
            retval.append(cur_mod)

    return retval


if __name__ == "__main__":  # pragma: no cover
    for i in get_plugins():
        print(i.type)
    pass
