"""Primitives for interacting with the PyJen plugin API"""
import os
import logging
import xml.etree.ElementTree as ElementTree
from pyjen.utils.plugin_base import PluginBase

# Path where all PyJen plugins are stored
PYJEN_PLUGIN_FOLDER = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "plugins"))


class PluginXML(object):
    """Class used to process XML configuration information associated with Jenkins plugins"""
    def __init__(self, xml_node):
        """
        :param xml_node: the XML sub-tree defining the properties of this plugin
        :type xml_node: :class:`xml.etree.ElementTree`
        """
        self._root = xml_node
        self._log = logging.getLogger(__name__)

    def get_module_name(self):
        """Gets the name of the plugin

        :returns: the plugin name
        :rtype: :class:`str`
        """
        attr = self._root.attrib['plugin']
        parts = attr.split('@')
        return parts[0]

    def get_class_name(self):
        """Gets the Java class name of the plugin

        :returns: the Java class name
        :rtype: :class:`str`
        """

        if "class" in self._root.attrib:
            return self._root.attrib['class']
        else:
            return self._root.tag

    def get_version(self):
        """Gets the version of the plugin

        :returns: the plugin version
        :rtype: :class:`str`
        """
        attr = self._root.attrib['plugin']
        parts = attr.split('@')
        return parts[1]


def get_plugins():
    """Returns list of classes for all plugins supported by PyJen

    :returns: list of classes for all PyJen plugins
    :rtype: :class:`list` of :class:`~.PluginBase` derived objects
    """
    all_modules = _load_modules(PYJEN_PLUGIN_FOLDER)
    retval = []
    for module in all_modules:
        retval.extend(_get_plugin_classes(module))
    return retval


def create_xml_plugin(xml_node):
    """Instantiates the appropriate XML-compatible PyJen plugin

    :param xml_node: the node of the XML configuration defining the plugin configuration
    :type xml_node: xml.etree.ElementTree
    :returns: a pre-initialized plugin of the appropriate type, or None if no supported plugin can be found
    :rtype: :class:`~.utils.plugin_base.PluginBase` derived class
    """
    pluginxml = PluginXML(xml_node)
    plugin = find_plugin(pluginxml.get_class_name())
    if plugin is None:
        return None

    return plugin(xml_node)


def find_plugin(plugin_type):
    """Locates a PyJen plugin of the given type

    :param str plugin_type: the descriptive type-name for the plugin to find
    :returns: reference to the plugin class for the specified type, or None if a compatible plugin could not be found
    """
    for plugin in get_plugins():
        if plugin.type == plugin_type:
            return plugin
    return None


def init_extension_plugin(config_xml, url):
    """Instantiates a plugin that extends one of the Jenkins native objects such as a view or job

    :param str config_xml: raw XML of the object to be encapsulated by a plugin
    :param str url: full REST API endpoint of the Jenkins object associated with the XML
    """
    pluginxml = PluginXML(ElementTree.fromstring(config_xml))
    all_plugins = get_plugins()
    for plugin in all_plugins:
        if plugin.type == pluginxml.get_class_name():
            return plugin(url)
    return None


def get_plugin_name(xml_node):
    """Extracts the name of a plugin from an XML snippet

    :param xml_node: the node of the XML configuration defining the plugin configuration
    :type xml_node: xml.etree.ElementTree
    :returns: Name of the plugin this snippet is generated by
    :rtype: :class:`str`
    """
    return PluginXML(xml_node).get_class_name()


def _get_plugin_classes(module):
    """Gets a list of all PyJen plugins from a given Python module

    :param module: A Python module object to be processed
    :returns: list of classes found within the given module that implement PyJen plugin interfaces
    :rtype: :class:`list` of :class:`~.PluginBase` objects
    """
    import inspect
    retval = []
    for cur_member in inspect.getmembers(module, inspect.isclass):
        if cur_member[1].__module__.startswith("pyjen.plugins."):
            if issubclass(cur_member[1], PluginBase):
                retval.append(cur_member[1])

    return retval


def _load_modules(path):
    """Gets a list of all modules found in a given path

    :param str path: path containing Python modules to be loaded
    :return: :class:`list` of objects of type 'module' found in the specified folder
    :rtype: :class:`list` of Python modules
    """
    import pkgutil
    import importlib
    # TODO: Consider how we should customize this prefix in case we want to load plugins from multiple paths / packages
    package_prefix = "pyjen.plugins."
    retval = []

    # First, check to see if any plugins have already been loaded
    import sys
    for cur_module_name in sys.modules:
        if cur_module_name.startswith(package_prefix):
            cur_module = sys.modules[cur_module_name]

            # Make sure to exclude 'package initialization' modules
            if cur_module is not None and not cur_module.__file__.endswith("__init__.py"):
                retval.append(cur_module)

            # TODO: Consider whether we need to consider re-loading plugins in certain cases

    # If not, then lets walk all modules in the plugin path and load them all
    for pkg_module in pkgutil.iter_modules([path], package_prefix):
        if not pkg_module[2]:
            cur_mod = importlib.import_module(pkg_module[1])

            if not cur_mod in retval:
                retval.append(cur_mod)

    # TODO: See whether we need to consider loading newly added plugins that may not have existed the first time
    #       this function is called
    return retval

if __name__ == "__main__":  # pragma: no cover
    #for i in get_plugins():
    #    print(i.type)
    pass
